# k邻近

下面是我们团队统计的各部电影的打斗镜头数和接吻镜头数，以及对应的电影类型：

|电影名称                  |打斗镜头|接吻镜头|电影类型|
|--------------------------|--------|--------|--------|
|California Man            |3       |104     |爱情片  |
|He's Not Really into Dudes|2       |100     |爱情片  |
|Beautiful Woman           |1       |81      |爱情片  |
|Kevin Longblade           |101     |10      |动作片  |
|Robo Slayer 3000          |99      |5       |动作片  |
|Amped II                  |98      |2       |动作片  |

我们团队希望能通过打斗镜头数和接吻镜头数来确定电影类型。为此，我们先看一下这个问题有哪些特点：

- 两个特征：打斗镜头数和接吻镜头数
- 目标变量是标称的：两种电影类型，不妨设0代表爱情片，1代表动作片
- 一个分类问题：目标变量就两类0和1

进行了一轮头脑风暴之后，我们团队提出了两种解决方案：

- 基于规则的算法：如果打斗数多于接吻数，那么电影类型就为1；如果接吻数多于打斗数，那么电影类型就为0
- 机器学习：使用分类模型--k邻近算法

下面我们主要考虑机器学习中的k邻近算法。

## k邻近算法

k邻近算法是一种分类算法，主要思想是衡量需要分类的对象与已经分类的对象的相似性，然后用最相似的已分类对象对应的类型作为需要分类对象的类型。首先介绍爱情动作片中使用的相似性度量。

### 相似性度量--欧式距离

相似性度量也是一种距离，在爱情动作片问题中，我们使用欧式距离：

![1](http://chart.googleapis.com/chart?cht=tx&chl=d(x%2Cy)%3D%5Csqrt%7B(x_0-y_0)%5E2%2B(x_1-y_1)%5E2%7D)

其中![2](http://chart.googleapis.com/chart?cht=tx&chl=x)和![3](http://chart.googleapis.com/chart?cht=tx&chl=y)分别表示两部电影，![4](http://chart.googleapis.com/chart?cht=tx&chl=x_0)和![5](http://chart.googleapis.com/chart?cht=tx&chl=y_0)分别表示两部电影的打斗数，![6](http://chart.googleapis.com/chart?cht=tx&chl=x_1)和![7](http://chart.googleapis.com/chart?cht=tx&chl=y_1)分别表示两部电影的接吻数。

假设![8](http://chart.googleapis.com/chart?cht=tx&chl=m%5Ei_%7B1%5Cleq%20i%5Cleq6%7D)表示样本中的6部电影，而需要分类的电影为![9](http://chart.googleapis.com/chart?cht=tx&chl=m)，它的打斗数为18次，接吻数为90次。下面计算它与前四部电影的欧式距离：

![10](http://chart.googleapis.com/chart?cht=tx&chl=d(m%2Cm%5E1)%3D%5Csqrt%7B(m_0-m%5E1_0)%5E2%2B(m_1-m%5E1_1)%5E2%7D%3D20.5)

![11](http://chart.googleapis.com/chart?cht=tx&chl=d(m%2Cm%5E2)%3D%5Csqrt%7B(m_0-m%5E2_0)%5E2%2B(m_1-m%5E2_1)%5E2%7D%3D18.9)

![12](http://chart.googleapis.com/chart?cht=tx&chl=d(m%2Cm%5E3)%3D%5Csqrt%7B(m_0-m%5E3_0)%5E2%2B(m_1-m%5E3_1)%5E2%7D%3D19.2)

![13](http://chart.googleapis.com/chart?cht=tx&chl=d(m%2Cm%5E4)%3D%5Csqrt%7B(m_0-m%5E4_0)%5E2%2B(m_1-m%5E4_1)%5E2%7D%3D115.2)

### k邻近中的k

k需要自己指定，比如：

- 当k=1时，18.9最小，因此把![14](http://chart.googleapis.com/chart?cht=tx&chl=m)和![15](http://chart.googleapis.com/chart?cht=tx&chl=m%5E2)归为一类，即![16](http://chart.googleapis.com/chart?cht=tx&chl=m)为爱情片
- 当k=2时，18.9和19.2最小，此时两部均为爱情片，即![17](http://chart.googleapis.com/chart?cht=tx&chl=m)为爱情片
- 当k=3时，18.9，19.2和20.5最小，此时三部均为爱情片，即![18](http://chart.googleapis.com/chart?cht=tx&chl=m)为爱情片
- 当k=4时，18.9，19.2，20.5和115.2最小，此时三部爱情片，一部动作片，由于爱情片的个数多于动作片的个数，因此![19](http://chart.googleapis.com/chart?cht=tx&chl=m)为爱情片

## 人民的好朋友scikit-learn

下面使用sickit-learn来复现3邻近算法：

```python
# -*- coding: utf-8 -*-
from sklearn import neighbors

# 步骤一：明确分类器，其中k=3，相似性度量为欧式距离
clf = neighbors.KNeighborsClassifier(3, weights='distance')

# 步骤二：训练
train_data_X = [
    [3, 104],
    [2, 100],
    [1, 81],
    [101, 10],
]
train_data_Y = [0, 0, 0, 1]
clf.fit(train_data_X, train_data_Y)

# 步骤三：测试
test_data_X = [
    [99, 5],
    [98, 2],
]
test_data_Y = [1, 1]
print clf.predict(test_data_X) # 结果为[1 1]，与test_data_Y比较，错误率为0，说明分类器很棒

# 步骤四：预测
print clf.predict([[18, 90]])[0] # 结果为0，因此预测结果为爱情片
```

## 问题集